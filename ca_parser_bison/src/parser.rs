/* A Bison parser, made by GNU Bison 3.8.2.  */

/* Skeleton implementation for Bison LALR(1) parsers in Rust

Copyright (C) 2007-2015, 2018-2020 Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
part or all of the Bison parser skeleton and distribute that work
under terms of your choice, so long as that work isn't itself a
parser generator using the skeleton or a modified version thereof
as a parser skeleton.  Alternatively, if you modify or redistribute
the parser skeleton itself, you may (at your option) remove this
special exception, which will cause the skeleton and the resulting
Bison output files to be licensed under the GNU General Public
License without this special exception.

This special exception was added by the Free Software Foundation in
version 2.2 of Bison.  */

/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
especially those whose name start with YY_ or yy_.  They are
private implementation details that can be changed or removed.  */

use std::convert::TryInto;

/* "%code use" blocks.  */
/* "src/parser.y":10  */

// NOTE: This (parser.rs) is auto generated by ca_parser_bison/src/parser.y working with ca_parser_bison/build.rs
use crate::lexer::Lexer;
use crate::lexer::Token;
use crate::loc::Loc;
use crate::value::*;
use std::path::PathBuf;

/* "src/parser.rs":54  */

/// A Bison parser, automatically generated from src/parser.y.
#[derive(Debug)]
pub struct Parser {
    /// Lexer that is used to get tokens
    pub yylexer: Lexer,
    // true if verbose error messages are enabled.
    #[allow(dead_code)]
    yy_error_verbose: bool,
    // number of errors so far
    yynerrs: i32,

    yyerrstatus_: i32,

    /* "%code parser_fields" blocks.  */
    /* "src/parser.y":19  */
    result: Option<i32>,
    /// Just an extra field for demonstration
    pub name: String,
    /// Enables debug printing
    pub debug: bool,
    pub output: Option<Value>,
    source: String,
    path: PathBuf, /* "src/parser.rs":82  */
}

#[inline]
fn i32_to_usize(v: i32) -> usize {
    v as usize
}

/// Maps token ID into human-readable name
pub fn token_name(id: i32) -> &'static str {
    /* ' */
    let first_token = Lexer::YYerror;
    if id > first_token + 1 {
        let pos: usize = (id - first_token + 1)
            .try_into()
            .expect("failed to cast token id into usize, is it negative?");
        Lexer::TOKEN_NAMES[pos]
    } else if id == 0 {
        "EOF"
    } else {
        panic!("token_name fails, {} (first token = {})", id, first_token)
    }
}

/// Local alias
type YYLoc = Loc;

impl Parser {
    // Version number for the Bison executable that generated this parser.
    #[allow(dead_code)]
    const BISON_VERSION: &'static str = "30802";
}

fn make_yylloc(rhs: &YYStack, n: usize) -> YYLoc {
    if 0 < n {
        YYLoc {
            begin: rhs.location_at(n - 1).begin,
            end: rhs.location_at(0).end,
        }
    } else {
        YYLoc {
            begin: rhs.location_at(0).end,
            end: rhs.location_at(0).end,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct SymbolKind {
    value: i32,
}

impl SymbolKind {
    #[allow(non_upper_case_globals)]
    const S_YYEOF: i32 = 0; /* "end of file"  */

    #[allow(non_upper_case_globals)]
    const S_YYerror: i32 = 1; /* error  */

    #[allow(non_upper_case_globals)]
    const S_YYUNDEF: i32 = 2; /* "invalid token"  */

    #[allow(non_upper_case_globals)]
    const S_tPLUS: i32 = 3; /* "+"  */

    #[allow(non_upper_case_globals)]
    const S_tMINUS: i32 = 4; /* "-"  */

    #[allow(non_upper_case_globals)]
    const S_tMUL: i32 = 5; /* "*"  */

    #[allow(non_upper_case_globals)]
    const S_tDIV: i32 = 6; /* "/"  */

    #[allow(non_upper_case_globals)]
    const S_tLPAREN: i32 = 7; /* "("  */

    #[allow(non_upper_case_globals)]
    const S_tRPAREN: i32 = 8; /* ")"  */

    #[allow(non_upper_case_globals)]
    const S_tLBRACK: i32 = 9; /* "{"  */

    #[allow(non_upper_case_globals)]
    const S_tRBRACK: i32 = 10; /* "}"  */

    #[allow(non_upper_case_globals)]
    const S_tCOLON: i32 = 11; /* ":"  */

    #[allow(non_upper_case_globals)]
    const S_tPERIOD: i32 = 12; /* "."  */

    #[allow(non_upper_case_globals)]
    const S_tAMPERSAND: i32 = 13; /* "&"  */

    #[allow(non_upper_case_globals)]
    const S_tSEMICOLON: i32 = 14; /* ";"  */

    #[allow(non_upper_case_globals)]
    const S_tPATHSEP: i32 = 15; /* "::"  */

    #[allow(non_upper_case_globals)]
    const S_tCOMMA: i32 = 16; /* ","  */

    #[allow(non_upper_case_globals)]
    const S_tASSIGN: i32 = 17; /* "="  */

    #[allow(non_upper_case_globals)]
    const S_tLET: i32 = 18; /* "let"  */

    #[allow(non_upper_case_globals)]
    const S_tI32: i32 = 19; /* "i32"  */

    #[allow(non_upper_case_globals)]
    const S_tI64: i32 = 20; /* "i64"  */

    #[allow(non_upper_case_globals)]
    const S_tI128: i32 = 21; /* "i128"  */

    #[allow(non_upper_case_globals)]
    const S_tU32: i32 = 22; /* "u32"  */

    #[allow(non_upper_case_globals)]
    const S_tU64: i32 = 23; /* "u64"  */

    #[allow(non_upper_case_globals)]
    const S_tSTRING: i32 = 24; /* "Text wrapped in quotes"  */

    #[allow(non_upper_case_globals)]
    const S_kwRETURN: i32 = 25; /* "return"  */

    #[allow(non_upper_case_globals)]
    const S_kwSTRUCT: i32 = 26; /* "struct"  */

    #[allow(non_upper_case_globals)]
    const S_kwIMPORT: i32 = 27; /* "import"  */

    #[allow(non_upper_case_globals)]
    const S_kwNEW: i32 = 28; /* "new"  */

    #[allow(non_upper_case_globals)]
    const S_kwEXTERN: i32 = 29; /* "extern"  */

    #[allow(non_upper_case_globals)]
    const S_tINFER: i32 = 30; /* "_"  */

    #[allow(non_upper_case_globals)]
    const S_tIDENTIFIER: i32 = 31; /* "local variable or method"  */

    #[allow(non_upper_case_globals)]
    const S_tNUM: i32 = 32; /* "number"  */

    #[allow(non_upper_case_globals)]
    const S_tFN: i32 = 33; /* "fn"  */

    #[allow(non_upper_case_globals)]
    const S_tERROR: i32 = 34; /* "controlled YYERROR"  */

    #[allow(non_upper_case_globals)]
    const S_tABORT: i32 = 35; /* "controlled YYABORT"  */

    #[allow(non_upper_case_globals)]
    const S_tACCEPT: i32 = 36; /* "controlled YYACCEPT"  */

    #[allow(non_upper_case_globals)]
    const S_YYACCEPT: i32 = 37; /* $accept  */

    #[allow(non_upper_case_globals)]
    const S_program: i32 = 38; /* program  */

    #[allow(non_upper_case_globals)]
    const S_items: i32 = 39; /* items  */

    #[allow(non_upper_case_globals)]
    const S_item: i32 = 40; /* item  */

    #[allow(non_upper_case_globals)]
    const S_struct: i32 = 41; /* struct  */

    #[allow(non_upper_case_globals)]
    const S_struct_fields: i32 = 42; /* struct_fields  */

    #[allow(non_upper_case_globals)]
    const S_struct_field: i32 = 43; /* struct_field  */

    #[allow(non_upper_case_globals)]
    const S_function: i32 = 44; /* function  */

    #[allow(non_upper_case_globals)]
    const S_function_args: i32 = 45; /* function_args  */

    #[allow(non_upper_case_globals)]
    const S_function_arg: i32 = 46; /* function_arg  */

    #[allow(non_upper_case_globals)]
    const S_import: i32 = 47; /* import  */

    #[allow(non_upper_case_globals)]
    const S_identifier: i32 = 48; /* identifier  */

    #[allow(non_upper_case_globals)]
    const S_path: i32 = 49; /* path  */

    #[allow(non_upper_case_globals)]
    const S_path_segment: i32 = 50; /* path_segment  */

    #[allow(non_upper_case_globals)]
    const S_block_expr: i32 = 51; /* block_expr  */

    #[allow(non_upper_case_globals)]
    const S_statements: i32 = 52; /* statements  */

    #[allow(non_upper_case_globals)]
    const S_statement: i32 = 53; /* statement  */

    #[allow(non_upper_case_globals)]
    const S_let_stmt: i32 = 54; /* let_stmt  */

    #[allow(non_upper_case_globals)]
    const S_return_stmt: i32 = 55; /* return_stmt  */

    #[allow(non_upper_case_globals)]
    const S_expr_stmt: i32 = 56; /* expr_stmt  */

    #[allow(non_upper_case_globals)]
    const S_ty: i32 = 57; /* ty  */

    #[allow(non_upper_case_globals)]
    const S_call_params: i32 = 58; /* call_params  */

    #[allow(non_upper_case_globals)]
    const S_none: i32 = 59; /* none  */

    #[allow(non_upper_case_globals)]
    const S_expr: i32 = 60; /* expr  */

    #[allow(non_upper_case_globals)]
    const S_literal_expr: i32 = 61; /* literal_expr  */

    #[allow(non_upper_case_globals)]
    const S_integer_literal: i32 = 62; /* integer_literal  */

    #[allow(non_upper_case_globals)]
    const S_string_literal: i32 = 63; /* string_literal  */

    #[allow(non_upper_case_globals)]
    const S_call_expr: i32 = 64; /* call_expr  */

    #[allow(non_upper_case_globals)]
    const S_path_expr: i32 = 65; /* path_expr  */

    #[allow(non_upper_case_globals)]
    const S_field_expression: i32 = 66; /* field_expression  */

    const VALUES_: &'static [SymbolKind] = &[
        SymbolKind {
            value: SymbolKind::S_YYEOF,
        },
        SymbolKind {
            value: SymbolKind::S_YYerror,
        },
        SymbolKind {
            value: SymbolKind::S_YYUNDEF,
        },
        SymbolKind {
            value: SymbolKind::S_tPLUS,
        },
        SymbolKind {
            value: SymbolKind::S_tMINUS,
        },
        SymbolKind {
            value: SymbolKind::S_tMUL,
        },
        SymbolKind {
            value: SymbolKind::S_tDIV,
        },
        SymbolKind {
            value: SymbolKind::S_tLPAREN,
        },
        SymbolKind {
            value: SymbolKind::S_tRPAREN,
        },
        SymbolKind {
            value: SymbolKind::S_tLBRACK,
        },
        SymbolKind {
            value: SymbolKind::S_tRBRACK,
        },
        SymbolKind {
            value: SymbolKind::S_tCOLON,
        },
        SymbolKind {
            value: SymbolKind::S_tPERIOD,
        },
        SymbolKind {
            value: SymbolKind::S_tAMPERSAND,
        },
        SymbolKind {
            value: SymbolKind::S_tSEMICOLON,
        },
        SymbolKind {
            value: SymbolKind::S_tPATHSEP,
        },
        SymbolKind {
            value: SymbolKind::S_tCOMMA,
        },
        SymbolKind {
            value: SymbolKind::S_tASSIGN,
        },
        SymbolKind {
            value: SymbolKind::S_tLET,
        },
        SymbolKind {
            value: SymbolKind::S_tI32,
        },
        SymbolKind {
            value: SymbolKind::S_tI64,
        },
        SymbolKind {
            value: SymbolKind::S_tI128,
        },
        SymbolKind {
            value: SymbolKind::S_tU32,
        },
        SymbolKind {
            value: SymbolKind::S_tU64,
        },
        SymbolKind {
            value: SymbolKind::S_tSTRING,
        },
        SymbolKind {
            value: SymbolKind::S_kwRETURN,
        },
        SymbolKind {
            value: SymbolKind::S_kwSTRUCT,
        },
        SymbolKind {
            value: SymbolKind::S_kwIMPORT,
        },
        SymbolKind {
            value: SymbolKind::S_kwNEW,
        },
        SymbolKind {
            value: SymbolKind::S_kwEXTERN,
        },
        SymbolKind {
            value: SymbolKind::S_tINFER,
        },
        SymbolKind {
            value: SymbolKind::S_tIDENTIFIER,
        },
        SymbolKind {
            value: SymbolKind::S_tNUM,
        },
        SymbolKind {
            value: SymbolKind::S_tFN,
        },
        SymbolKind {
            value: SymbolKind::S_tERROR,
        },
        SymbolKind {
            value: SymbolKind::S_tABORT,
        },
        SymbolKind {
            value: SymbolKind::S_tACCEPT,
        },
        SymbolKind {
            value: SymbolKind::S_YYACCEPT,
        },
        SymbolKind {
            value: SymbolKind::S_program,
        },
        SymbolKind {
            value: SymbolKind::S_items,
        },
        SymbolKind {
            value: SymbolKind::S_item,
        },
        SymbolKind {
            value: SymbolKind::S_struct,
        },
        SymbolKind {
            value: SymbolKind::S_struct_fields,
        },
        SymbolKind {
            value: SymbolKind::S_struct_field,
        },
        SymbolKind {
            value: SymbolKind::S_function,
        },
        SymbolKind {
            value: SymbolKind::S_function_args,
        },
        SymbolKind {
            value: SymbolKind::S_function_arg,
        },
        SymbolKind {
            value: SymbolKind::S_import,
        },
        SymbolKind {
            value: SymbolKind::S_identifier,
        },
        SymbolKind {
            value: SymbolKind::S_path,
        },
        SymbolKind {
            value: SymbolKind::S_path_segment,
        },
        SymbolKind {
            value: SymbolKind::S_block_expr,
        },
        SymbolKind {
            value: SymbolKind::S_statements,
        },
        SymbolKind {
            value: SymbolKind::S_statement,
        },
        SymbolKind {
            value: SymbolKind::S_let_stmt,
        },
        SymbolKind {
            value: SymbolKind::S_return_stmt,
        },
        SymbolKind {
            value: SymbolKind::S_expr_stmt,
        },
        SymbolKind {
            value: SymbolKind::S_ty,
        },
        SymbolKind {
            value: SymbolKind::S_call_params,
        },
        SymbolKind {
            value: SymbolKind::S_none,
        },
        SymbolKind {
            value: SymbolKind::S_expr,
        },
        SymbolKind {
            value: SymbolKind::S_literal_expr,
        },
        SymbolKind {
            value: SymbolKind::S_integer_literal,
        },
        SymbolKind {
            value: SymbolKind::S_string_literal,
        },
        SymbolKind {
            value: SymbolKind::S_call_expr,
        },
        SymbolKind {
            value: SymbolKind::S_path_expr,
        },
        SymbolKind {
            value: SymbolKind::S_field_expression,
        },
    ];

    pub(crate) fn get(n: i32) -> &'static SymbolKind {
        &Self::VALUES_[i32_to_usize(n)]
    }

    pub(crate) fn code(&self) -> i32 {
        self.value
    }

    /* YYNAMES_[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
    First, the terminals, then, starting at \a YYNTOKENS_, nonterminals.  */
    #[allow(non_upper_case_globals)]
    const yynames_: &'static [&'static str] = &[
        "end of file",
        "error",
        "invalid token",
        "+",
        "-",
        "*",
        "/",
        "(",
        ")",
        "{",
        "}",
        ":",
        ".",
        "&",
        ";",
        "::",
        ",",
        "=",
        "let",
        "i32",
        "i64",
        "i128",
        "u32",
        "u64",
        "Text wrapped in quotes",
        "return",
        "struct",
        "import",
        "new",
        "extern",
        "_",
        "local variable or method",
        "number",
        "fn",
        "controlled YYERROR",
        "controlled YYABORT",
        "controlled YYACCEPT",
        "$accept",
        "program",
        "items",
        "item",
        "struct",
        "struct_fields",
        "struct_field",
        "function",
        "function_args",
        "function_arg",
        "import",
        "identifier",
        "path",
        "path_segment",
        "block_expr",
        "statements",
        "statement",
        "let_stmt",
        "return_stmt",
        "expr_stmt",
        "ty",
        "call_params",
        "none",
        "expr",
        "literal_expr",
        "integer_literal",
        "string_literal",
        "call_expr",
        "path_expr",
        "field_expression",
        "<<NULL>>",
    ];

    /* The user-facing name of this symbol.  */
    pub(crate) fn name(&self) -> String {
        let code: usize = self.code().try_into().unwrap();
        Self::yynames_[code].to_owned()
    }
}

const DYMMY_SYMBOL_KIND: SymbolKind = SymbolKind { value: 0 };

impl Lexer {
    /* Token kinds.  */
    /// Token `` "end of file" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const YYEOF: i32 = 0;
    /// Token `` error ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const YYerror: i32 = 256;
    /// Token `` "invalid token" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const YYUNDEF: i32 = 257;
    /// Token `` "+" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tPLUS: i32 = 258;
    /// Token `` "-" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tMINUS: i32 = 259;
    /// Token `` "*" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tMUL: i32 = 260;
    /// Token `` "/" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tDIV: i32 = 261;
    /// Token `` "(" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tLPAREN: i32 = 262;
    /// Token `` ")" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tRPAREN: i32 = 263;
    /// Token `` "{" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tLBRACK: i32 = 264;
    /// Token `` "}" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tRBRACK: i32 = 265;
    /// Token `` ":" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tCOLON: i32 = 266;
    /// Token `` "." ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tPERIOD: i32 = 267;
    /// Token `` "&" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tAMPERSAND: i32 = 268;
    /// Token `` ";" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tSEMICOLON: i32 = 269;
    /// Token `` "::" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tPATHSEP: i32 = 270;
    /// Token `` "," ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tCOMMA: i32 = 271;
    /// Token `` "=" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tASSIGN: i32 = 272;
    /// Token `` "let" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tLET: i32 = 273;
    /// Token `` "i32" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tI32: i32 = 274;
    /// Token `` "i64" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tI64: i32 = 275;
    /// Token `` "i128" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tI128: i32 = 276;
    /// Token `` "u32" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tU32: i32 = 277;
    /// Token `` "u64" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tU64: i32 = 278;
    /// Token `` "Text wrapped in quotes" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tSTRING: i32 = 279;
    /// Token `` "return" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const kwRETURN: i32 = 280;
    /// Token `` "struct" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const kwSTRUCT: i32 = 281;
    /// Token `` "import" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const kwIMPORT: i32 = 282;
    /// Token `` "new" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const kwNEW: i32 = 283;
    /// Token `` "extern" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const kwEXTERN: i32 = 284;
    /// Token `` "_" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tINFER: i32 = 285;
    /// Token `` "local variable or method" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tIDENTIFIER: i32 = 286;
    /// Token `` "number" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tNUM: i32 = 287;
    /// Token `` "fn" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tFN: i32 = 288;
    /// Token `` "controlled YYERROR" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tERROR: i32 = 289;
    /// Token `` "controlled YYABORT" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tABORT: i32 = 290;
    /// Token `` "controlled YYACCEPT" ``, to be returned by the scanner.
    #[allow(non_upper_case_globals, dead_code)]
    pub const tACCEPT: i32 = 291;

    // Deprecated, use YYEOF instead.
    #[allow(dead_code)]
    const EOF: i32 = Self::YYEOF;

    // Token values
    #[allow(dead_code)]
    pub(crate) const TOKEN_NAMES: &'static [&'static str] = &[
        "YYEOF",
        "YYerror",
        "YYUNDEF",
        "tPLUS",
        "tMINUS",
        "tMUL",
        "tDIV",
        "tLPAREN",
        "tRPAREN",
        "tLBRACK",
        "tRBRACK",
        "tCOLON",
        "tPERIOD",
        "tAMPERSAND",
        "tSEMICOLON",
        "tPATHSEP",
        "tCOMMA",
        "tASSIGN",
        "tLET",
        "tI32",
        "tI64",
        "tI128",
        "tU32",
        "tU64",
        "tSTRING",
        "kwRETURN",
        "kwSTRUCT",
        "kwIMPORT",
        "kwNEW",
        "kwEXTERN",
        "tINFER",
        "tIDENTIFIER",
        "tNUM",
        "tFN",
        "tERROR",
        "tABORT",
        "tACCEPT",
    ];
}

impl Parser {
    fn yycdebug(&self, s: &str) {
        if false {
            eprintln!("{}", s);
        }
    }
}

/// Local alias
type YYValue = Value;

#[derive(Debug)]
struct YYStackItem {
    state: i32,
    value: YYValue,
    loc: YYLoc,
}

#[derive(Debug)]
pub struct YYStack {
    stack: Vec<YYStackItem>,
}

impl YYStack {
    pub(crate) fn new() -> Self {
        Self {
            stack: Vec::with_capacity(20),
        }
    }

    pub(crate) fn push(&mut self, state: i32, value: YYValue, loc: YYLoc) {
        self.stack.push(YYStackItem { state, value, loc });
    }

    pub(crate) fn pop(&mut self) {
        self.stack.pop();
    }

    pub(crate) fn pop_n(&mut self, num: usize) {
        let len = self.stack.len() - num;
        self.stack.truncate(len);
    }

    pub(crate) fn state_at(&self, i: usize) -> i32 {
        self.stack[self.len() - 1 - i].state
    }

    pub(crate) fn location_at(&self, i: usize) -> &YYLoc {
        &self.stack[self.len() - 1 - i].loc
    }

    pub(crate) fn borrow_value_at(&self, i: usize) -> &YYValue {
        &self.stack[self.len() - 1 - i].value
    }

    pub(crate) fn owned_value_at(&mut self, i: usize) -> YYValue {
        let len = self.len();
        std::mem::take(&mut self.stack[len - 1 - i].value)
    }

    pub(crate) fn len(&self) -> usize {
        self.stack.len()
    }
}

impl std::fmt::Display for YYStack {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let states = self
            .stack
            .iter()
            .map(|e| e.state.to_string())
            .collect::<Vec<String>>()
            .join(" ");
        let values = self
            .stack
            .iter()
            .map(|e| format!("{:?}", e.value))
            .collect::<Vec<String>>()
            .join(" ");
        f.write_fmt(format_args!(
            "Stack now states = {} / values = {:?} ",
            states, values
        ))
    }
}

impl Parser {
    /// Returned by a Bison action in order to stop the parsing process and
    /// return success (true).
    pub(crate) const YYACCEPT: i32 = 0;

    /// Returned by a Bison action in order to stop the parsing process and
    /// return failure (false).
    pub(crate) const YYABORT: i32 = 1;

    /// Returned by a Bison action in order to start error recovery without
    /// printing an error message.
    pub(crate) const YYERROR: i32 = 2;

    /// Internal return codes that are not supported for user semantic
    /// actions.
    pub(crate) const YYERRLAB: i32 = 3;
    pub(crate) const YYNEWSTATE: i32 = 4;
    pub(crate) const YYDEFAULT: i32 = 5;
    pub(crate) const YYREDUCE: i32 = 6;
    pub(crate) const YYERRLAB1: i32 = 7;
    #[allow(dead_code)]
    pub(crate) const YYRETURN: i32 = 8;

    /// Whether error recovery is being done.  In this state, the parser
    /// reads token until it reaches a known state, and then restarts normal
    /// operation.
    #[allow(dead_code)]
    pub(crate) fn recovering(&self) -> bool {
        self.yyerrstatus_ == 0
    }

    // Compute post-reduction state.
    // yystate:   the current state
    // yysym:     the nonterminal to push on the stack
    fn yy_lr_goto_state(&self, yystate: i32, yysym: i32) -> i32 {
        let idx = i32_to_usize(yysym - Self::YYNTOKENS_);
        let yyr = Self::yypgoto_[idx] + yystate;
        if (0..=Self::YYLAST_).contains(&yyr) {
            let yyr = i32_to_usize(yyr);
            if Self::yycheck_[yyr] == yystate {
                return Self::yytable_[yyr];
            }
        }
        Self::yydefgoto_[idx]
    }

    fn yyaction(&mut self, yyn: i32, yystack: &mut YYStack, yylen: &mut usize) -> Result<i32, ()> {
        // If YYLEN is nonzero, implement the default value of the action:
        // '$$ = $1'.  Otherwise, use the top of the stack.
        //
        // Otherwise, the following line sets YYVAL to garbage.
        // This behavior is undocumented and Bison
        // users should not rely upon it.
        #[allow(unused_assignments)]
        let mut yyval: YYValue = YYValue::Uninitialized;
        let yyloc: YYLoc = make_yylloc(yystack, *yylen);

        self.yy_reduce_print(yyn, yystack);

        match yyn {
            2 =>
            /* program: items  */
            /* "src/parser.y":105  */
            {
                self.result = Some(0);
                self.output = Some(Value::Program(Box::new(yystack.owned_value_at(0))));
                yyval = Value::Program(Box::new(yystack.owned_value_at(0)))
            }

            3 =>
            /* program: error  */
            /* "src/parser.y":109  */
            {
                self.result = None;
                yyval = Value::None;
            }

            4 =>
            /* items: item  */
            /* "src/parser.y":113  */
            {
                yyval = Value::ValueList(vec![yystack.owned_value_at(0)]);
            }

            5 =>
            /* items: items item  */
            /* "src/parser.y":116  */
            {
                let mut vl = ValueList::from(yystack.owned_value_at(1));
                vl.push(yystack.owned_value_at(0));
                let v = Value::ValueList(vl);
                yyval = v;
            }

            6 =>
            /* item: struct  */
            /* "src/parser.y":122  */
            {
                yyval = Value::Item(Box::new(yystack.owned_value_at(0)))
            }

            7 =>
            /* item: function  */
            /* "src/parser.y":125  */
            {
                yyval = Value::Item(Box::new(yystack.owned_value_at(0)))
            }

            8 =>
            /* item: import  */
            /* "src/parser.y":128  */
            {
                yyval = Value::Item(Box::new(yystack.owned_value_at(0)))
            }

            9 =>
            /* struct: "struct" identifier "{" struct_fields "}"  */
            /* "src/parser.y":131  */
            {
                yyval = Value::Struct(
                    Box::new(yystack.owned_value_at(3)),
                    Box::new(yystack.owned_value_at(1)),
                )
            }

            10 =>
            /* struct_fields: struct_field  */
            /* "src/parser.y":134  */
            {
                yyval = Value::ValueList(vec![yystack.owned_value_at(0)])
            }

            11 =>
            /* struct_fields: struct_fields "," struct_field  */
            /* "src/parser.y":137  */
            {
                let mut vl = crate::value::ValueList::from(yystack.owned_value_at(2));
                vl.push(yystack.owned_value_at(0));
                yyval = Value::ValueList(vl);
            }

            12 =>
            /* struct_field: identifier ":" ty  */
            /* "src/parser.y":142  */
            {
                yyval = Value::StructField(
                    Box::new(yystack.owned_value_at(2)),
                    Box::new(yystack.owned_value_at(0)),
                )
            }

            13 =>
            /* function: "fn" identifier "(" function_args ")" ":" ty block_expr  */
            /* "src/parser.y":146  */
            {
                yyval = Value::Function(
                    Ident::from(yystack.owned_value_at(6)),
                    Box::new(yystack.owned_value_at(4)),
                    Box::new(yystack.owned_value_at(1)),
                    Box::new(yystack.owned_value_at(0)),
                );
            }

            14 =>
            /* function: "extern" "fn" identifier "(" function_args ")" ":" ty  */
            /* "src/parser.y":149  */
            {
                yyval = Value::ExternFunction(
                    Ident::from(yystack.owned_value_at(5)),
                    Box::new(yystack.owned_value_at(3)),
                    Box::new(yystack.owned_value_at(0)),
                )
            }

            15 =>
            /* function_args: function_arg  */
            /* "src/parser.y":152  */
            {
                yyval = Value::ValueList(vec![yystack.owned_value_at(0)]);
            }

            16 =>
            /* function_args: function_args "," function_arg  */
            /* "src/parser.y":155  */
            {
                let mut args = crate::value::ValueList::from(yystack.owned_value_at(2));
                args.push(yystack.owned_value_at(0));
                let v = Value::ValueList(args);
                yyval = v;
            }

            17 =>
            /* function_arg: identifier ":" ty  */
            /* "src/parser.y":161  */
            {
                yyval = Value::FunctionArg(
                    Ident::from(yystack.owned_value_at(2)),
                    Box::new(yystack.owned_value_at(0)),
                );
            }

            18 =>
            /* function_arg: none  */
            /* "src/parser.y":164  */
            {
                yyval = Value::None;
            }

            19 =>
            /* import: "import" identifier  */
            /* "src/parser.y":167  */
            {
                // let mut p = PathBuf::new();
                let mut p = self.path.clone();
                assert!(p.pop());
                let id = Ident::from(yystack.owned_value_at(0));
                p.push(id.clone());
                p.set_extension("ca");
                let src = std::fs::read_to_string(p.clone())
                    .expect(&format!("Dependency file {:?} not found.", p));
                let lexer = Lexer::new(&src);
                let parser = Parser::new(lexer, "idk", &src, p);
                let prog = parser.do_parse().2.unwrap();
                yyval = Value::Import(Box::new(Value::Ident(id)), Box::new(prog));
            }

            20 =>
            /* identifier: "local variable or method"  */
            /* "src/parser.y":180  */
            {
                let tok = Token::from(yystack.owned_value_at(0));
                yyval = Value::Ident(tok.token_value);
            }

            21 =>
            /* path: path_segment  */
            /* "src/parser.y":185  */
            {
                yyval = Value::ValueList(vec![yystack.owned_value_at(0)]);
            }

            22 =>
            /* path: path "::" path_segment  */
            /* "src/parser.y":188  */
            {
                let mut args = ValueList::from(yystack.owned_value_at(2));
                args.push(yystack.owned_value_at(0));
                let v = Value::ValueList(args);
                yyval = v;
            }

            23 =>
            /* path_segment: identifier  */
            /* "src/parser.y":194  */
            {
                yyval = Value::Ident(Ident::from(yystack.owned_value_at(0)));
            }

            24 =>
            /* block_expr: "{" statements "}"  */
            /* "src/parser.y":198  */
            {
                yyval = Value::BlockExpr(Box::new(yystack.owned_value_at(1)))
            }

            25 =>
            /* block_expr: "{" "}"  */
            /* "src/parser.y":201  */
            {
                yyval = Value::BlockExpr(Box::new(Value::ValueList(vec![])))
            }

            26 =>
            /* statements: statement  */
            /* "src/parser.y":204  */
            {
                yyval = Value::ValueList(vec![yystack.owned_value_at(0)]);
            }

            27 =>
            /* statements: statements ";" statement  */
            /* "src/parser.y":207  */
            {
                let mut stmts = ValueList::from(yystack.owned_value_at(2));
                stmts.push(yystack.owned_value_at(0));
                let v = Value::ValueList(stmts);
                yyval = v;
            }

            28 =>
            /* statement: let_stmt  */
            /* "src/parser.y":213  */
            {
                yyval = Value::Statement(Box::new(yystack.owned_value_at(0)));
            }

            29 =>
            /* statement: return_stmt  */
            /* "src/parser.y":216  */
            {
                yyval = Value::Statement(Box::new(yystack.owned_value_at(0)));
            }

            30 =>
            /* statement: expr_stmt  */
            /* "src/parser.y":219  */
            {
                yyval = Value::Statement(Box::new(yystack.owned_value_at(0)))
            }

            31 =>
            /* let_stmt: "let" identifier ":" ty "=" expr  */
            /* "src/parser.y":222  */
            {
                yyval = Value::LetStatement(
                    Box::new(yystack.owned_value_at(4)),
                    Box::new(yystack.owned_value_at(2)),
                    Box::new(yystack.owned_value_at(0)),
                );
            }

            32 =>
            /* return_stmt: "return" expr  */
            /* "src/parser.y":225  */
            {
                yyval = Value::ReturnStatement(Box::new(yystack.owned_value_at(0)))
            }

            33 =>
            /* expr_stmt: expr  */
            /* "src/parser.y":228  */
            {
                yyval = Value::ExprStatement(Box::new(yystack.owned_value_at(0)))
            }

            34 =>
            /* ty: "i32"  */
            /* "src/parser.y":233  */
            {
                yyval = Value::Ty(Box::new(Value::Int32))
            }

            35 =>
            /* ty: "i64"  */
            /* "src/parser.y":236  */
            {
                yyval = Value::Ty(Box::new(Value::Int64))
            }

            36 =>
            /* ty: "i128"  */
            /* "src/parser.y":239  */
            {
                yyval = Value::Ty(Box::new(Value::Int128))
            }

            37 =>
            /* ty: "u32"  */
            /* "src/parser.y":242  */
            {
                yyval = Value::Ty(Box::new(Value::UInt32))
            }

            38 =>
            /* ty: "u64"  */
            /* "src/parser.y":245  */
            {
                yyval = Value::Ty(Box::new(Value::UInt64))
            }

            39 =>
            /* ty: path  */
            /* "src/parser.y":248  */
            {
                yyval = Value::Ty(Box::new(yystack.owned_value_at(0)))
            }

            40 =>
            /* ty: "_"  */
            /* "src/parser.y":251  */
            {
                yyval = Value::Ty(Box::new(Value::Infer))
            }

            41 =>
            /* ty: "&" ty  */
            /* "src/parser.y":254  */
            {
                yyval = Value::Ty(Box::new(Value::PointerTy(Box::new(
                    yystack.owned_value_at(0),
                ))))
            }

            42 =>
            /* call_params: none  */
            /* "src/parser.y":258  */
            {
                yyval = Value::ValueList(vec![])
            }

            43 =>
            /* call_params: expr  */
            /* "src/parser.y":260  */
            {
                yyval = Value::ValueList(vec![yystack.owned_value_at(0)])
            }

            44 =>
            /* call_params: call_params "," expr  */
            /* "src/parser.y":262  */
            {
                let mut params = ValueList::from(yystack.owned_value_at(2));
                params.push(yystack.owned_value_at(0));
                let v = Value::ValueList(params);
                yyval = v;
            }

            45 =>
            /* none: %empty  */
            /* "src/parser.y":268  */
            {
                yyval = Value::None
            }

            46 =>
            /* expr: literal_expr  */
            /* "src/parser.y":276  */
            {
                yyval = Value::Expr(Box::new(yystack.owned_value_at(0)))
            }

            47 =>
            /* expr: "new" path "(" call_params ")"  */
            /* "src/parser.y":279  */
            {
                yyval = Value::Expr(Box::new(Value::NewExpr(
                    Box::new(yystack.owned_value_at(3)),
                    Box::new(yystack.owned_value_at(1)),
                )))
            }

            48 =>
            /* expr: block_expr  */
            /* "src/parser.y":282  */
            {
                yyval = Value::Expr(Box::new(yystack.owned_value_at(0)))
            }

            49 =>
            /* expr: call_expr  */
            /* "src/parser.y":285  */
            {
                yyval = Value::Expr(Box::new(yystack.owned_value_at(0)))
            }

            50 =>
            /* expr: "(" expr ")"  */
            /* "src/parser.y":288  */
            {
                yyval = yystack.owned_value_at(1);
            }

            51 =>
            /* expr: path_expr  */
            /* "src/parser.y":291  */
            {
                yyval = Value::Expr(Box::new(yystack.owned_value_at(0)))
            }

            52 =>
            /* expr: field_expression  */
            /* "src/parser.y":294  */
            {
                yyval = Value::Expr(Box::new(yystack.owned_value_at(0)))
            }

            53 =>
            /* expr: expr "+" expr  */
            /* "src/parser.y":297  */
            {
                yyval = Value::Expr(Box::new(Value::ArithExpr(
                    Box::new(yystack.owned_value_at(2)),
                    Op::Add,
                    Box::new(yystack.owned_value_at(0)),
                )))
            }

            54 =>
            /* expr: expr "-" expr  */
            /* "src/parser.y":300  */
            {
                yyval = Value::Expr(Box::new(Value::ArithExpr(
                    Box::new(yystack.owned_value_at(2)),
                    Op::Sub,
                    Box::new(yystack.owned_value_at(0)),
                )))
            }

            55 =>
            /* expr: expr "*" expr  */
            /* "src/parser.y":303  */
            {
                yyval = Value::Expr(Box::new(Value::ArithExpr(
                    Box::new(yystack.owned_value_at(2)),
                    Op::Mul,
                    Box::new(yystack.owned_value_at(0)),
                )))
            }

            56 =>
            /* expr: expr "/" expr  */
            /* "src/parser.y":306  */
            {
                yyval = Value::Expr(Box::new(Value::ArithExpr(
                    Box::new(yystack.owned_value_at(2)),
                    Op::Div,
                    Box::new(yystack.owned_value_at(0)),
                )))
            }

            57 =>
            /* literal_expr: integer_literal  */
            /* "src/parser.y":310  */
            {
                yyval = Value::LiteralExpr(Box::new(yystack.owned_value_at(0)))
            }

            58 =>
            /* literal_expr: string_literal  */
            /* "src/parser.y":313  */
            {
                yyval = Value::LiteralExpr(Box::new(yystack.owned_value_at(0)))
            }

            59 =>
            /* integer_literal: "number" ty  */
            /* "src/parser.y":316  */
            {
                yyval = Value::IntegerLiteral(
                    Token::from(yystack.owned_value_at(1)).token_value,
                    Box::new(yystack.owned_value_at(0)),
                )
            }

            60 =>
            /* integer_literal: "number"  */
            /* "src/parser.y":319  */
            {
                yyval = Value::IntegerLiteral(
                    Token::from(yystack.owned_value_at(0)).token_value,
                    Box::new(Value::Ty(Box::new(Value::Int32))),
                )
            }

            61 =>
            /* string_literal: "Text wrapped in quotes"  */
            /* "src/parser.y":322  */
            {
                yyval = Value::StringLiteral(Token::from(yystack.owned_value_at(0)).token_value)
            }

            62 =>
            /* call_expr: path "(" call_params ")"  */
            /* "src/parser.y":325  */
            {
                yyval = Value::CallExpr(
                    Box::new(yystack.owned_value_at(3)),
                    Box::new(yystack.owned_value_at(1)),
                )
            }

            63 =>
            /* path_expr: path  */
            /* "src/parser.y":328  */
            {
                yyval = Value::PathExpr(Box::new(yystack.owned_value_at(0)))
            }

            64 =>
            /* field_expression: expr "." identifier  */
            /* "src/parser.y":331  */
            {
                yyval = Value::FieldExpr(
                    Box::new(yystack.owned_value_at(2)),
                    Box::new(yystack.owned_value_at(0)),
                )
            }

            /* "src/parser.rs":1253  */
            _ => {}
        }

        if let YYValue::Uninitialized = yyval {
            panic!(
                "yyval is Uninitialized in rule at line {}",
                Self::yyrline_[i32_to_usize(yyn)]
            );
        }

        self.yy_symbol_print(
            "-> $$ =",
            SymbolKind::get(Self::yyr1_[i32_to_usize(yyn)]),
            &yyval,
            &yyloc,
        );

        yystack.pop_n(*yylen);
        *yylen = 0;
        /* Shift the result of the reduction.  */
        let yystate = self.yy_lr_goto_state(yystack.state_at(0), Self::yyr1_[i32_to_usize(yyn)]);
        yystack.push(yystate, yyval, yyloc);
        Ok(Self::YYNEWSTATE)
    }

    // Print this symbol on YYOUTPUT.
    fn yy_symbol_print(&self, s: &str, yykind: &SymbolKind, yyvalue: &YYValue, yylocation: &YYLoc) {
        if false {
            self.yycdebug(&format!(
                "{}{} {:?} ( {:?}: {:?} )", // " fix highlighting
                s,
                if yykind.code() < Self::YYNTOKENS_ {
                    " token "
                } else {
                    " nterm "
                },
                yykind.name(),
                yylocation,
                yyvalue
            ))
        }
    }

    /// Parses given input. Returns true if the parsing was successful.
    pub fn parse(&mut self) -> bool {
        /* @$.  */
        let mut yyloc: YYLoc;

        /* Lookahead token kind.  */
        let mut yychar: i32 = Self::YYEMPTY_;
        /* Lookahead symbol kind.  */
        let mut yytoken = &DYMMY_SYMBOL_KIND;

        /* State.  */
        let mut yyn: i32 = 0;
        let mut yylen: usize = 0;
        let mut yystate: i32 = 0;
        let mut yystack = YYStack::new();
        let mut label: i32 = Self::YYNEWSTATE;

        /* The location where the error started.  */
        let mut yyerrloc: YYLoc = YYLoc { begin: 0, end: 0 };

        /* Location. */
        let mut yylloc: YYLoc = YYLoc { begin: 0, end: 0 };

        /* Semantic value of the lookahead.  */
        let mut yylval: YYValue = YYValue::Uninitialized;

        self.yycdebug("Starting parse");
        self.yyerrstatus_ = 0;
        self.yynerrs = 0;

        /* Initialize the stack.  */
        yystack.push(yystate, yylval.clone(), yylloc);

        loop {
            match label {
                // New state.  Unlike in the C/C++ skeletons, the state is already
                // pushed when we come here.
                Self::YYNEWSTATE => {
                    if false {
                        self.yycdebug(&format!("Entering state {}", yystate));
                        eprintln!("{}", yystack);
                    }

                    /* Accept? */
                    if yystate == Self::YYFINAL_ {
                        return true;
                    }

                    /* Take a decision.  First try without lookahead.  */
                    yyn = Self::yypact_[i32_to_usize(yystate)];
                    if yy_pact_value_is_default(yyn) {
                        label = Self::YYDEFAULT;
                        continue;
                    }

                    /* Read a lookahead token.  */
                    if yychar == Self::YYEMPTY_ {
                        self.yycdebug("Reading a token");
                        let token = self.next_token();
                        yychar = token.token_type;
                        yylloc = token.loc;
                        yylval = YYValue::from_token(token);
                    }

                    /* Convert token to internal form.  */
                    yytoken = Self::yytranslate_(yychar);
                    self.yy_symbol_print("Next token is", yytoken, &yylval, &yylloc);

                    if yytoken == SymbolKind::get(1) {
                        // The scanner already issued an error message, process directly
                        // to error recovery.  But do not keep the error token as
                        // lookahead, it is too special and may lead us to an endless
                        // loop in error recovery. */
                        yychar = Lexer::YYUNDEF;
                        yytoken = SymbolKind::get(2);
                        yyerrloc = yylloc;
                        label = Self::YYERRLAB1;
                    } else {
                        // If the proper action on seeing token YYTOKEN is to reduce or to
                        // detect an error, take that action.
                        yyn += yytoken.code();
                        if yyn < 0
                            || Self::YYLAST_ < yyn
                            || Self::yycheck_[i32_to_usize(yyn)] != yytoken.code()
                        {
                            label = Self::YYDEFAULT;
                        }
                        /* <= 0 means reduce or error.  */
                        else {
                            yyn = Self::yytable_[i32_to_usize(yyn)];
                            if yyn <= 0 {
                                if yy_table_value_is_error(yyn) {
                                    label = Self::YYERRLAB;
                                } else {
                                    yyn = -yyn;
                                    label = Self::YYREDUCE;
                                }
                            } else {
                                /* Shift the lookahead token.  */
                                self.yy_symbol_print("Shifting", yytoken, &yylval, &yylloc);

                                /* Discard the token being shifted.  */
                                yychar = Self::YYEMPTY_;

                                /* Count tokens shifted since error; after three, turn off error status.  */
                                if self.yyerrstatus_ > 0 {
                                    self.yyerrstatus_ -= 1;
                                }

                                yystate = yyn;
                                yystack.push(
                                    yystate,
                                    std::mem::take(&mut yylval),
                                    std::mem::take(&mut yylloc),
                                );
                                label = Self::YYNEWSTATE;
                            }
                        }
                    }
                    continue;
                } // YYNEWSTATE

                // yydefault -- do the default action for the current state.
                Self::YYDEFAULT => {
                    yyn = Self::yydefact_[i32_to_usize(yystate)];
                    if yyn == 0 {
                        label = Self::YYERRLAB;
                    } else {
                        label = Self::YYREDUCE;
                    }
                    continue;
                } // YYDEFAULT

                // yyreduce -- Do a reduction.
                Self::YYREDUCE => {
                    yylen = i32_to_usize(Self::yyr2_[i32_to_usize(yyn)]);
                    label = match self.yyaction(yyn, &mut yystack, &mut yylen) {
                        Ok(label) => label,
                        Err(_) => Self::YYERROR,
                    };
                    yystate = yystack.state_at(0);
                    continue;
                } // YYREDUCE

                // yyerrlab -- here on detecting error
                Self::YYERRLAB => {
                    /* If not already recovering from an error, report this error.  */
                    if self.yyerrstatus_ == 0 {
                        self.yynerrs += 1;
                        if yychar == Self::YYEMPTY_ {
                            yytoken = &DYMMY_SYMBOL_KIND;
                        }
                        self.report_syntax_error(&yystack, yytoken, yylloc);
                    }
                    yyerrloc = yylloc;
                    if self.yyerrstatus_ == 3 {
                        // If just tried and failed to reuse lookahead token after an error, discard it.

                        if yychar <= Lexer::YYEOF {
                            /* Return failure if at end of input.  */
                            if yychar == Lexer::YYEOF {
                                return false;
                            }
                        } else {
                            yychar = Self::YYEMPTY_;
                        }
                    }

                    // Else will try to reuse lookahead token after shifting the error token.
                    label = Self::YYERRLAB1;
                    continue;
                } // YYERRLAB

                // errorlab -- error raised explicitly by YYERROR.
                Self::YYERROR => {
                    /* Do not reclaim the symbols of the rule which action triggered
                    this YYERROR.  */
                    yystack.pop_n(yylen);
                    yylen = 0;
                    yystate = yystack.state_at(0);
                    label = Self::YYERRLAB1;
                    continue;
                } // YYERROR

                // yyerrlab1 -- common code for both syntax error and YYERROR.
                Self::YYERRLAB1 => {
                    self.yyerrstatus_ = 3; /* Each real token shifted decrements this.  */

                    // Pop stack until we find a state that shifts the error token.
                    loop {
                        yyn = Self::yypact_[i32_to_usize(yystate)];
                        if !yy_pact_value_is_default(yyn) {
                            yyn += SymbolKind {
                                value: SymbolKind::S_YYerror,
                            }
                            .code();
                            if (0..=Self::YYLAST_).contains(&yyn) {
                                let yyn_usize = i32_to_usize(yyn);
                                if Self::yycheck_[yyn_usize] == SymbolKind::S_YYerror {
                                    yyn = Self::yytable_[yyn_usize];
                                    if 0 < yyn {
                                        break;
                                    }
                                }
                            }
                        }

                        // Pop the current state because it cannot handle the error token.
                        if yystack.len() == 1 {
                            return false;
                        }

                        yyerrloc = *yystack.location_at(0);
                        yystack.pop();
                        yystate = yystack.state_at(0);
                        if false {
                            eprintln!("{}", yystack);
                        }
                    }

                    if label == Self::YYABORT {
                        /* Leave the switch.  */
                        continue;
                    }

                    /* Muck with the stack to setup for yylloc.  */
                    yystack.push(0, YYValue::Uninitialized, yylloc);
                    yystack.push(0, YYValue::Uninitialized, yyerrloc);
                    yyloc = make_yylloc(&yystack, 2);
                    yystack.pop_n(2);

                    /* Shift the error token.  */
                    self.yy_symbol_print(
                        "Shifting",
                        SymbolKind::get(Self::yystos_[i32_to_usize(yyn)]),
                        &yylval,
                        &yyloc,
                    );

                    yystate = yyn;
                    yystack.push(yyn, yylval.clone(), yyloc);
                    label = Self::YYNEWSTATE;
                    continue;
                } // YYERRLAB1

                // Accept
                Self::YYACCEPT => {
                    return true;
                }

                // Abort.
                Self::YYABORT => {
                    return false;
                }

                _ => {
                    panic!("internal bison error: unknown label {}", label);
                }
            }
        }
    }
}

// Whether the given `yypact_` value indicates a defaulted state.
fn yy_pact_value_is_default(yyvalue: i32) -> bool {
    yyvalue == YYPACT_NINF_
}

// Whether the given `yytable_`
// value indicates a syntax error.
// yyvalue: the value to check
fn yy_table_value_is_error(yyvalue: i32) -> bool {
    yyvalue == YYTABLE_NINF_
}

const YYPACT_NINF_: i32 = -83;
const YYTABLE_NINF_: i32 = -1;

impl Parser {
    /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
    #[allow(non_upper_case_globals)]
    const yypact_: &'static [i32] = &[
        26, -83, -21, -21, -22, -21, 32, 95, -83, -83, -83, -83, -83, 39, -83, -21, 28, -83, -83,
        -21, 35, -21, 18, -83, 58, -21, -4, -83, 59, -83, -83, -21, 87, 8, 62, -21, 87, -83, 87,
        -83, -83, -83, -83, -83, -83, -83, 43, -83, -83, 63, 87, -83, -83, -83, -21, 87, 74, -83,
        -83, 47, -83, 53, -83, -21, -83, 53, -21, 87, 15, -83, 37, -83, -83, -83, -83, 83, -83,
        -83, -83, -83, -83, -83, 108, 79, 83, 24, -83, 53, -83, 73, 53, 53, 53, 53, -21, -83, 87,
        53, 33, -83, 83, -83, 120, 120, 81, 81, -83, 77, 60, -83, 53, 53, -83, 83, 83,
    ];

    /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
    Performed when YYTABLE does not specify something else to do.  Zero
    means the default is an error.  */
    #[allow(non_upper_case_globals)]
    const yydefact_: &'static [i32] = &[
        0, 3, 0, 0, 0, 0, 0, 2, 4, 6, 7, 8, 20, 0, 19, 0, 0, 1, 5, 0, 0, 45, 0, 10, 0, 45, 0, 15,
        0, 18, 9, 0, 0, 0, 0, 45, 0, 11, 0, 34, 35, 36, 37, 38, 40, 23, 39, 21, 12, 0, 0, 16, 17,
        41, 0, 0, 0, 22, 14, 0, 13, 0, 25, 0, 61, 0, 0, 60, 63, 48, 0, 26, 28, 29, 30, 33, 46, 57,
        58, 49, 51, 52, 0, 0, 32, 0, 59, 45, 24, 0, 0, 0, 0, 0, 0, 50, 0, 45, 0, 42, 43, 27, 53,
        54, 55, 56, 64, 0, 0, 62, 0, 0, 47, 44, 31,
    ];

    /* YYPGOTO[NTERM-NUM].  */
    #[allow(non_upper_case_globals)]
    const yypgoto_: &'static [i32] = &[
        -83, -83, -83, 89, -83, -83, 68, -83, 78, 67, -83, -2, -30, 61, 71, -83, 30, -83, -83, -83,
        -29, 34, -82, -47, -83, -83, -83, -83, -83, -83,
    ];

    /* YYDEFGOTO[NTERM-NUM].  */
    #[allow(non_upper_case_globals)]
    const yydefgoto_: &'static [i32] = &[
        0, 6, 7, 8, 9, 22, 23, 10, 26, 27, 11, 45, 68, 47, 69, 70, 71, 72, 73, 74, 48, 98, 29, 75,
        76, 77, 78, 79, 80, 81,
    ];

    /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
    positive, shift that token.  If negative, reduce the rule whose
    number is the opposite.  If YYTABLE_NINF, syntax error.  */
    #[allow(non_upper_case_globals)]
    const yytable_: &'static [i32] = &[
        13, 14, 46, 16, 34, 99, 46, 52, 46, 53, 12, 15, 35, 20, 82, 99, 49, 24, 84, 28, 46, 56, 87,
        28, 35, 46, 58, 1, 30, 24, 54, 97, 17, 28, 31, 21, 85, 46, 86, 54, 100, 109, 25, 102, 103,
        104, 105, 88, 19, 110, 100, 89, 2, 3, 61, 4, 59, 62, 54, 5, 61, 83, 59, 113, 114, 63, 46,
        107, 112, 32, 36, 64, 65, 50, 55, 66, 110, 64, 12, 67, 61, 66, 59, 59, 12, 67, 90, 91, 92,
        93, 96, 63, 106, 94, 111, 94, 18, 64, 65, 37, 38, 66, 51, 33, 12, 67, 39, 40, 41, 42, 43,
        90, 91, 92, 93, 57, 95, 44, 12, 101, 94, 2, 3, 0, 4, 92, 93, 60, 5, 0, 0, 108, 94,
    ];

    #[allow(non_upper_case_globals)]
    const yycheck_: &'static [i32] = &[
        2, 3, 32, 5, 8, 87, 36, 36, 38, 38, 31, 33, 16, 15, 61, 97, 8, 19, 65, 21, 50, 50, 7, 25,
        16, 55, 55, 1, 10, 31, 15, 7, 0, 35, 16, 7, 66, 67, 67, 15, 87, 8, 7, 90, 91, 92, 93, 10,
        9, 16, 97, 14, 26, 27, 7, 29, 9, 10, 15, 33, 7, 63, 9, 110, 111, 18, 96, 96, 8, 11, 11, 24,
        25, 11, 11, 28, 16, 24, 31, 32, 7, 28, 9, 9, 31, 32, 3, 4, 5, 6, 11, 18, 94, 12, 17, 12, 7,
        24, 25, 31, 13, 28, 35, 25, 31, 32, 19, 20, 21, 22, 23, 3, 4, 5, 6, 54, 8, 30, 31, 89, 12,
        26, 27, -1, 29, 5, 6, 56, 33, -1, -1, 97, 12,
    ];

    /* YYSTOS[STATE-NUM] -- The symbol kind of the accessing symbol of
    state STATE-NUM.  */
    #[allow(non_upper_case_globals)]
    const yystos_: &'static [i32] = &[
        0, 1, 26, 27, 29, 33, 38, 39, 40, 41, 44, 47, 31, 48, 48, 33, 48, 0, 40, 9, 48, 7, 42, 43,
        48, 7, 45, 46, 48, 59, 10, 16, 11, 45, 8, 16, 11, 43, 13, 19, 20, 21, 22, 23, 30, 48, 49,
        50, 57, 8, 11, 46, 57, 57, 15, 11, 57, 50, 57, 9, 51, 7, 10, 18, 24, 25, 28, 32, 49, 51,
        52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 66, 60, 48, 60, 49, 57, 7, 10, 14, 3, 4, 5, 6,
        12, 8, 11, 7, 58, 59, 60, 53, 60, 60, 60, 60, 48, 57, 58, 8, 16, 17, 8, 60, 60,
    ];

    /* YYR1[RULE-NUM] -- Symbol kind of the left-hand side of rule RULE-NUM.  */
    #[allow(non_upper_case_globals)]
    const yyr1_: &'static [i32] = &[
        0, 37, 38, 38, 39, 39, 40, 40, 40, 41, 42, 42, 43, 44, 44, 45, 45, 46, 46, 47, 48, 49, 49,
        50, 51, 51, 52, 52, 53, 53, 53, 54, 55, 56, 57, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 59,
        60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 62, 62, 63, 64, 65, 66,
    ];

    /* YYR2[RULE-NUM] -- Number of symbols on the right-hand side of rule RULE-NUM.  */
    #[allow(non_upper_case_globals)]
    const yyr2_: &'static [i32] = &[
        0, 2, 1, 1, 1, 2, 1, 1, 1, 5, 1, 3, 3, 8, 8, 1, 3, 3, 1, 2, 1, 1, 3, 1, 3, 2, 1, 3, 1, 1,
        1, 6, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 3, 0, 1, 5, 1, 1, 3, 1, 1, 3, 3, 3, 3, 1, 1, 2,
        1, 1, 4, 1, 3,
    ];

    /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
    #[allow(non_upper_case_globals)]
    const yyrline_: &'static [i32] = &[
        0, 105, 105, 109, 113, 116, 122, 125, 128, 131, 134, 137, 142, 146, 149, 152, 155, 161,
        164, 167, 180, 185, 188, 194, 198, 201, 204, 207, 213, 216, 219, 222, 225, 228, 233, 236,
        239, 242, 245, 248, 251, 254, 258, 260, 262, 268, 276, 279, 282, 285, 288, 291, 294, 297,
        300, 303, 306, 310, 313, 316, 319, 322, 325, 328, 331,
    ];

    // Report on the debug stream that the rule yyrule is going to be reduced.
    fn yy_reduce_print(&self, yyrule: i32, yystack: &YYStack) {
        if !(false) {
            return;
        }

        let yylno = Self::yyrline_[i32_to_usize(yyrule)];
        let yynrhs = Self::yyr2_[i32_to_usize(yyrule)];
        // Print the symbols being reduced, and their result.
        self.yycdebug(&format!(
            "Reducing stack by rule {} (line {}):",
            /* " fix */ yyrule - 1,
            yylno
        ));

        // The symbols being reduced.
        for yyi in 0..yynrhs {
            let state: usize = i32_to_usize(yystack.state_at(i32_to_usize(yynrhs - (yyi + 1))));
            self.yy_symbol_print(
                &format!("   ${} =", yyi + 1),
                SymbolKind::get(Self::yystos_[state]),
                yystack.borrow_value_at(i32_to_usize(yynrhs - (yyi + 1))),
                yystack.location_at(i32_to_usize(yynrhs - (yyi + 1))),
            );
        }
    }

    /* YYTRANSLATE_(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
    as returned by yylex, with out-of-bounds checking.  */
    fn yytranslate_(t: i32) -> &'static SymbolKind {
        // Last valid token kind.
        let code_max: i32 = 291;
        if t <= 0 {
            SymbolKind::get(0)
        } else if t <= code_max {
            let t = i32_to_usize(t);
            SymbolKind::get(Self::yytranslate_table_[t])
        } else {
            SymbolKind::get(2)
        }
    }
    #[allow(non_upper_case_globals)]
    const yytranslate_table_: &'static [i32] = &[
        0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
        14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
    ];

    const YYLAST_: i32 = 132;
    const YYEMPTY_: i32 = -2;
    const YYFINAL_: i32 = 17;
    const YYNTOKENS_: i32 = 37;
}

/* "src/parser.y":335  */

impl Parser {
    /// "Sucess" status-code of the parser
    pub const ACCEPTED: i32 = -1;

    /// "Failure" status-code of the parser
    pub const ABORTED: i32 = -2;

    /// Constructor
    pub fn new<'b>(lexer: Lexer, name: &str, source: &str, path: PathBuf) -> Self {
        Self {
            yy_error_verbose: true,
            yynerrs: 0,
            debug: false,
            yyerrstatus_: 0,
            yylexer: lexer,
            result: None,
            name: name.to_owned(),
            output: None,
            source: source.to_string(),
            path,
        }
    }

    /// Wrapper around generated `parse` method that also
    /// extracts `result` field and returns it.
    pub fn do_parse(mut self) -> (Option<i32>, String, Option<Value>) {
        self.parse();
        (self.result, self.name, self.output)
    }

    fn next_token(&mut self) -> Token {
        self.yylexer.yylex()
    }

    fn report_syntax_error(&self, _stack: &YYStack, _yytoken: &SymbolKind, loc: YYLoc) {
        //TODO: Look into using stack for error messages
        let source = self.source.to_string();
        crate::pretty::print_error(&source, loc.to_range(), self.yylexer.line + 1);
    }
}
