use ca_ast::*;
grammar();


pub Program: Program = {
   <i:Item*> => Program{items:i}
}
pub Item: Item = {
    <f:Function> => Item::Function(f),
    <s:Struct> => Item::Struct(s)
}


pub Stmt: Stmt = {
    "let" <name:Expr> <ty:ColTy?> "=" <val:ExprWithMath> => Stmt::LetStmt{name: name.assume_ident(), ty: ty, value: val},
    "return" <e:ExprWithMath> => Stmt::Return(Box::new(e)),
    <e:Expr> => Stmt::ExprStmt(e)
}
pub ColTy: Ty = {
    ":" <ty:Ty> => ty
}
// Function
pub Function: Function = {
    <ty:Ty> <name:Expr> <a:FunctionArgs> <e:ExprWithMath> => Function{name: name.assume_ident(), args:a, body: e, ty}
}
// pub FunctionArgs: Vec<FunctionArg> = {
//     <FunctionArg> => vec![<>],
//     (<FunctionArg> ",")* => <>,
//     <f:(<FunctionArg> ",")+> <l:FunctionArg> => vec![f, vec![l]].into_iter().flatten().collect()
// }
pub FunctionArgs: Vec<FunctionArg> = {
    Comma<FunctionArg>
}
Comma<T>: Vec<T> = {
    <T> => vec![<>],
    (<T> ",")* => <>,
    <f:(<T> ",")+> <l:T> => vec![f, vec![l]].into_iter().flatten().collect()

}
pub FunctionArg: FunctionArg = {
    "'" <ident: IdentExpr> ":" <ty: Ty> => FunctionArg{ty: ty, ident: ident.assume_ident()}
}

pub Struct: Struct = {
    "struct" <name: IdentExpr> "{" <fields:StructField*> "}" => Struct{name: name.assume_ident(), fields}
}
pub StructField: StructField = {
    <name:IdentExpr> ":" <ty:Ty> => StructField{name: name.assume_ident(), ty: ty}
}
pub ExprWithMath: Expr = {
    OrExpression
}
pub OrExpression: Expr = {
    <e1:Expr> "|" <e2:XorExpression> => Expr::BinOp(Box::new(e1), Op::Or, Box::new(e2)),
    XorExpression
}
pub XorExpression: Expr = {
    <e1: XorExpression> "^" <e2: AndExpression> => Expr::BinOp(Box::new(e1), Op::Xor, Box::new(e2)),
    AndExpression
}
pub AndExpression: Expr = {
    <e1: AndExpression> "&" <e2: RelationExpression> => Expr::BinOp(Box::new(e1), Op::And,Box::new(e2)),
    RelationExpression
}

pub RelationExpression: Expr = {
    <e1: RelationExpression> <s: RelationOp> <e2: ShiftExpression> => Expr::BinOp(Box::new(e1), s, Box::new(e2)),
    ShiftExpression
}

pub ShiftExpression: Expr = {
    <e1: ShiftExpression> <s:ShiftOp> <e2: ArithmaticExpression> => Expr::BinOp(Box::new(e1), s, Box::new(e2)),
    ArithmaticExpression
}
pub ArithmaticExpression: Expr = {
    <e1: ArithmaticExpression> <o:AddOp> <e2: Term> => Expr::BinOp(Box::new(e1), o, Box::new(e2)),
    Term
}

pub Expr: Expr = {
    LiteralExpr => Expr::LiteralExpr(<>),
    "{" <s:(Stmt*)> "}" => Expr::Block(s),
    IdentExpr,
    CallExpr,
    IfExpr
}
pub IfExpr: Expr = {
    "if" <predicate:ExprWithMath> <then:Expr> "else" <elze:Expr> => Expr::If(Box::new(predicate), Box::new(then), Box::new(elze))
}
pub CallExpr: Expr = {
    <name: IdentExpr> "(" <body:Comma<Expr>?> ")" => Expr::Call(name.assume_ident(), body)
}
pub IdentExpr: Expr = {
    Identifier => Expr::Ident(<>),
}

pub Term: Expr = {
    <a:Term> <op:MulOp> <b:Factor> => Expr::BinOp(Box::new(a), op, Box::new(b)),
    Factor
}
pub Factor: Expr = {
    <op:UnaryOp> <e:Factor> => Expr::UnaryOp(op, Box::new(e)),
    <e:Expr> => e,
}
pub Ty: Ty = {
    Identifier => Ty::Named(<>),
    "i32" => Ty::Int32,
    "bool" => Ty::Bool,
    "()" => Ty::Unit
}
// region: thing
pub ShiftOp: Op = {
    ">>" => Op::LShift,
    "<<" => Op::RShift
}
pub AddOp: Op = {
    "+" => Op::Add,
    "-" => Op::Sub
};
pub UnaryOp: UnaryOp = {
    "~" => UnaryOp::Invert,
    "-" => UnaryOp::Sub
};
pub MulOp: Op = {
    "*" => Op::Mul,
    "/" => Op::Div
};
pub RelationOp: Op = {
    ">" => Op::Gt,
    "<" => Op::Lt
}
// endregion: thing

pub Identifier: String = {
    r"[a-zA-Z]+[a-zA-Z0-9]*"  => String::from(<>),
}
pub LiteralExpr: Literal = {
    <n:r"[0-9]+"> => Literal::Integer(n.parse::<i64>().unwrap()),
    StringLiteral => Literal::String(<>)
}
pub StringLiteral: String = {
   <s:r#""[a-zA-Z0-9]+""#> => s.to_string()
}
